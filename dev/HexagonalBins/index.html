<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hexagonal Binning · MinistryOfCoolWalks.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://SuperGrobi.github.io/MinistryOfCoolWalks.jl/HexagonalBins/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MinistryOfCoolWalks.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../CenterlineCorrection/">Centerline correction</a></li><li><a class="tocitem" href="../ShadowIntersection/">Shadow intersections</a></li><li><a class="tocitem" href="../Routing/">Routing</a></li><li class="is-active"><a class="tocitem" href>Hexagonal Binning</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Remarks"><span>Remarks</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Hexagonal Binning</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hexagonal Binning</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/main/docs/src/HexagonalBins.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hexagonal-Bins"><a class="docs-heading-anchor" href="#Hexagonal-Bins">Hexagonal Bins</a><a id="Hexagonal-Bins-1"></a><a class="docs-heading-anchor-permalink" href="#Hexagonal-Bins" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>I guess this is the best way to aggregate some properties over a geographic area. Since I need a very specific set of aggregations and want to plot them in <code>Folium.jl</code> (or <code>Leaflet.jl</code>, if I could get that thing to a stable state...)</p><h2 id="Remarks"><a class="docs-heading-anchor" href="#Remarks">Remarks</a><a id="Remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Remarks" title="Permalink"></a></h2><p>The binning function works, but is not really flexible enough for being this complicated...</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><ul><li><a href="#MinistryOfCoolWalks.aggregator_dataframe_polygon_area-Tuple{Any, Any}"><code>MinistryOfCoolWalks.aggregator_dataframe_polygon_area</code></a></li><li><a href="#MinistryOfCoolWalks.aggregator_graph_vertex_count-Tuple{Any, Any, Any}"><code>MinistryOfCoolWalks.aggregator_graph_vertex_count</code></a></li><li><a href="#MinistryOfCoolWalks.get_crs_for_hexagons-Tuple{DataFrames.DataFrame}"><code>MinistryOfCoolWalks.get_crs_for_hexagons</code></a></li><li><a href="#MinistryOfCoolWalks.hex_center-Tuple{Hexagons.Hexagon, Any}"><code>MinistryOfCoolWalks.hex_center</code></a></li><li><a href="#MinistryOfCoolWalks.hexagon_area-Tuple{Any, Any}"><code>MinistryOfCoolWalks.hexagon_area</code></a></li><li><a href="#MinistryOfCoolWalks.hexagon_histogram-Tuple{Any, Any, Any}"><code>MinistryOfCoolWalks.hexagon_histogram</code></a></li><li><a href="#MinistryOfCoolWalks.hexagon_histogram_OLD-Union{Tuple{T}, Tuple{Any, DataFrames.DataFrame, Any}} where T"><code>MinistryOfCoolWalks.hexagon_histogram_OLD</code></a></li><li><a href="#MinistryOfCoolWalks.hexagon_histogram_OLD-Union{Tuple{T}, Tuple{Any, Any, Graphs.AbstractGraph, Any}} where T"><code>MinistryOfCoolWalks.hexagon_histogram_OLD</code></a></li><li><a href="#MinistryOfCoolWalks.hexagonify-Tuple{Any, Any}"><code>MinistryOfCoolWalks.hexagonify</code></a></li><li><a href="#MinistryOfCoolWalks.hexes2polys-Tuple{Any, Any}"><code>MinistryOfCoolWalks.hexes2polys</code></a></li><li><a href="#MinistryOfCoolWalks.hexgrid_buffer-Tuple{Any}"><code>MinistryOfCoolWalks.hexgrid_buffer</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.aggregator_dataframe_polygon_area-Tuple{Any, Any}" href="#MinistryOfCoolWalks.aggregator_dataframe_polygon_area-Tuple{Any, Any}"><code>MinistryOfCoolWalks.aggregator_dataframe_polygon_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggregator_dataframe_polygon_area(row, hextree)</code></pre><p>aggregator to get the area of polygonal data in <code>row.geometry</code> in each hexagon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L351-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.aggregator_graph_vertex_count-Tuple{Any, Any, Any}" href="#MinistryOfCoolWalks.aggregator_graph_vertex_count-Tuple{Any, Any, Any}"><code>MinistryOfCoolWalks.aggregator_graph_vertex_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggregator_graph_vertex_count(vert, g, hextree)</code></pre><p>aggregator to get the number of vertices of the graph <code>g</code> in each hexagon. Uses the <code>:pointgeom</code> property of the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L367-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.get_crs_for_hexagons-Tuple{DataFrames.DataFrame}" href="#MinistryOfCoolWalks.get_crs_for_hexagons-Tuple{DataFrames.DataFrame}"><code>MinistryOfCoolWalks.get_crs_for_hexagons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_crs_for_hexagons(df::DataFrame)
get_crs_for_hexagons(g::AbstractMetaGraph)</code></pre><p>unified interface for accessing the local coordinate system of dataframes and graphs that support it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.hex_center-Tuple{Hexagons.Hexagon, Any}" href="#MinistryOfCoolWalks.hex_center-Tuple{Hexagons.Hexagon, Any}"><code>MinistryOfCoolWalks.hex_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hex_center(hex::Hexagons.Hexagon, r)</code></pre><p>caculates the centerpoint of the <code>hex</code> with radius <code>r</code>. Returns an <code>ArchGDAL</code> point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.hexagon_area-Tuple{Any, Any}" href="#MinistryOfCoolWalks.hexagon_area-Tuple{Any, Any}"><code>MinistryOfCoolWalks.hexagon_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hexagon_area(dx, dy)</code></pre><p>area of a hexagon with radius 1, that is scaled by <code>dx</code> in x direction, and by <code>dy</code> in y direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.hexagon_histogram-Tuple{Any, Any, Any}" href="#MinistryOfCoolWalks.hexagon_histogram-Tuple{Any, Any, Any}"><code>MinistryOfCoolWalks.hexagon_histogram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hexagon_histogram(aggregator, geom_source, radius; buffer=0, danger_value=10000, filter_values=x -&gt; true)</code></pre><p>calculates the &quot;generalised histogram&quot; for data in a <code>DataFrame</code> or <code>MetaGraph</code>. For both these types, we expect the following methods to be implemented:</p><ul><li><code>project_local!</code></li><li><code>build_rtree</code> (<code>val</code> should be a <code>NamedTuple</code> with at least the <code>ArchGDAL.IGeometry</code> under the keyword of <code>orig</code>).</li><li><code>hexagonify</code></li><li><code>get_crs_for_hexagons</code></li><li><code>project_back!</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>aggregator</code>: closure <code>(actual_intersections::Vector{SpatialElem}, hexagon::ArchGDAL.IGemometry{WKBPolygon})-&gt;T</code>, where <code>T</code> is the type of result in each hexagon-bin.   the first Argument is a Vector of the <code>SpatialElem</code>ents in the R-Tree of <code>geom_source</code>, where <code>ArchGDAL.intersects(hexagon, intersection.val.orig)==true</code>. The second   argument is the hexagon which is currently aggregated over.</li><li><code>geom_source</code>: source of geometry for R-Tree (and maybe other data.), currently, <code>DataFrame</code> and <code>AbstractMetaGraph</code> are supported.</li><li><code>radius</code>: radius of hexagons in which the bins should be calculated. (Passed to <code>hexagonify</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>buffer=0</code>: Number of times the hexagons should be buffered before the aggregation.</li><li><code>danger_value=10000</code>: Number of predicted hexes above which <code>hexagonify</code> will fail.</li><li><code>filter_values=x-&gt;true</code>: Only hexagons where the <code>filter_values(aggregation_value)==true</code> will be returned.</li></ul><p><strong>Process</strong></p><p>We project <code>geom_source</code> to a local coordinate system and calculate the hexagonalisation of the area defined by it. The projected <code>geom_source</code> is the converted into an <code>R-Tree</code>. For each hexagon in the hexagonalisation we calculate the value within that hexagon using the <code>aggregator</code>, filter these <code>values</code> with <code>filter_values</code>, project everything back, and return only the hexagons and <code>values</code> where <code>filter_values(value)==true</code>.</p><p>Returns <code>(filtered_hexagons, filtered_values)</code></p><p><strong>Examples</strong></p><p>To get the number of nodes of a <code>ShadowGraph</code> in each hexagon with more than 0 nodes, you can do something like this:</p><pre><code class="language-julia hljs">hexes, values = hexagon_histogram(shadow_graph, 50; filter_values=(&gt;(0))) inters, hex
    count(i -&gt; i.val.type == :vertex, inters)
end</code></pre><p>To get the total area of (possibly overlapping) buildings do:</p><pre><code class="language-julia hljs">hexes, values = hexagon_histogram(buildings, 50) do inters, hex
    geom = mapreduce(ArchGDAL.union, inters; init=ArchGDAL.createpolygon()) do i
        ArchGDAL.intersection(hex, i.val.orig)
    end
    return ArchGDAL.geomarea(geom)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L141-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.hexagon_histogram_OLD-Union{Tuple{T}, Tuple{Any, Any, Graphs.AbstractGraph, Any}} where T" href="#MinistryOfCoolWalks.hexagon_histogram_OLD-Union{Tuple{T}, Tuple{Any, Any, Graphs.AbstractGraph, Any}} where T"><code>MinistryOfCoolWalks.hexagon_histogram_OLD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hexagon_histogram_OLD(aggregator, iterator, g::AbstractGraph, radius;
    combinator=+, init::T=0.0,
    buffer=0, danger_value=10000, filter_values=x -&gt; true) where {T}</code></pre><p><strong>see the docstring for the other method taking a dataframe, for an in depth explanation of everything.</strong></p><p>!!! danger &quot;Do not use!&quot; This function was the first attempt at hexagonal histograms, and is kept around for sentimental     reasons, and to be deleted once the replacement <code>hexagon_histogram</code> is proven to work better, easier and more flexible.</p><p>calculates the generalised histogram for data in a graph, by looping over the <code>iterator</code>. Most often, this value is either <code>vertices(g)</code> or <code>edges(g)</code>. <code>g</code> is expected to have the following props: <code>:center_lon, :center_lat, :crs</code>.</p><p><strong>The aggregator</strong></p><p>now receives <code>(i, g, hextree)</code> as arguments, where <code>i</code> is the current state of the <code>iterator</code>, <code>g</code> is the graph, and <code>hextree</code> is the RTree of hexagons. Apart from that, it is expected to behave in the same way as the one from the <code>DataFrame</code> version of this function. All other statements given there do apply as well. </p><p><strong>Example</strong></p><p>To get the number of vertices in a hexagon, you can do something like:</p><pre><code class="language-julia hljs">hexes, values = hexagon_histogram(Graphs.vertices(g), g, 50) do vert, g, hextree
    values = zeros(length(hextree))
    for inter in intersects_with(hextree, rect_from_geom(get_prop(g, vert, :pointgeom)))
        values[inter.id] += 1
    end
    return values
end</code></pre><p>Aggregators for this method are prefixed with <code>aggregator_graph_</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L299-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.hexagon_histogram_OLD-Union{Tuple{T}, Tuple{Any, DataFrames.DataFrame, Any}} where T" href="#MinistryOfCoolWalks.hexagon_histogram_OLD-Union{Tuple{T}, Tuple{Any, DataFrames.DataFrame, Any}} where T"><code>MinistryOfCoolWalks.hexagon_histogram_OLD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hexagon_histogram_OLD(aggregator, gdf::DataFrame, radius;
    combinator=+, init::T=0.0,
    buffer=0, danger_value=10000, filter_values=x -&gt; true) where {T}</code></pre><p>calculates the &quot;generalised histogram&quot; for data in a dataframe <code>gdf</code>, which is expected to have the <code>&quot;center_lon&quot;</code> and <code>&quot;center_lat&quot;</code> metadata, as well as a column named <code>:geometry</code>, which will be projected to local coordinates for this function.</p><p>!!! danger &quot;Do not use!&quot; This function was the first attempt at hexagonal histograms, and is kept around for sentimental     reasons, and to be deleted once the replacement <code>hexagon_histogram</code> is proven to work better, easier and more flexible.</p><p>After projecting the we calculate the appropriate hexagon cover with hexagons of radius <code>radius</code>. The keywordarguments of <code>buffer</code> and <code>danger_value</code> are passed to the <code>hexagonify</code> function accordingly.</p><p>We then build an rtree out of the resulting hexagonal geometries, which will be passed to the <code>aggregator</code> function.</p><p>for each row, we call the <code>aggregator</code> and combine each element of returned vector with a <code>values</code> vector  by calling <code>values[i] = combinator(values[i], aggregator(...)[i])</code> for each <code>i in 1:number_of_hexagons</code>.</p><p>Returns <code>(hexagons, values)</code> for those values for which <code>filter_values(value) == true</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>combinator=+</code>: function used to combine the elements from each call to <code>aggregator</code> with the values from previous calls to aggregator. Signature: <code>(a::T, b)-&gt;c::T</code>.</li><li><code>init::T=0.0</code>: value and <code>eltype</code> with which to fill the <code>values</code> array on construction.</li><li><code>buffer=0</code>: amount of times the hexgrid should be buffered after filling the area.</li><li><code>danger_value=10000</code>: expected number of hexagons above which the hexagonify function will throw an error.</li><li><code>filter_values=x-&gt;true</code>: function to decide if a resulting value should be returned.</li></ul><p><strong>The aggregator</strong></p><p>the aggregator is a closure (or function) <code>(DataFrames.DataFrameRow, SpatialIndexing.RTree) -&gt; Vector{T}</code>, which calculates the contribution of the values in the given <code>row</code> towards the total value of each hexagonal cell, the index of the return vector corresponds to the hexagon. In the end, all of these contributions are added to give the final value.</p><p>A few aggregators will be implemented below, prefixed with <code>aggregator_dataframe_</code>.</p><p><strong>Example</strong></p><p>To get the area of the buildings given as polygons in each hexagon, you can do:</p><pre><code class="language-julia hljs">hexes, values = hexagon_histogram(buildings, 50; filter_values=(&gt;(0.0))) do r, hextree
    values = zeros(length(hextree))
    for inter in intersects_with(hextree, rect_from_geom(r.geometry))
        if ArchGDAL.intersects(inter.val.prep, r.geometry)
            values[inter.id] += ArchGDAL.geomarea(ArchGDAL.intersection(inter.val.orig, r.geometry))
        end
    end
    return values
end</code></pre><p><strong>Drawbacks</strong></p><p>Note that this implementation only allows for the calculation of aggregations which are linear in each row. To get nonlinear values, you currently have to decompose the values you are after into multiple <code>hexagon_histogram</code> calls, and build the value yourself. If you want for example the total building height divided by the number of buildings in each hex cell, you would have calculate them separately, and do the division afterwards. Also, all things that are not expressed as addition are not going to work. Things such as the maximum height of a building withing the hexagon.</p><p><strong>Future</strong></p><p>Most of this feels like it could feasibly be written as a <code>mapreduce</code>...</p><p>Somehow, it would be nicer if we were to transform the inner loop into one over the hexagons. As such, every aggregation function would be possible, and this in general makes a little bit more sense. For that to work, we would have to somehow build an RTree out of the DataFrame. Which would be possible, I guess, but a bit more work that this thing here. (was not too bad...) #TODid: Implement that and a better rtree_building in <code>CoolWalksUtils.jl</code>...</p><p>There is a lot of nearly duplicate code going on here. Not sure what I can do about that though. (the rebuild did fix that...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L212-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.hexagonify-Tuple{Any, Any}" href="#MinistryOfCoolWalks.hexagonify-Tuple{Any, Any}"><code>MinistryOfCoolWalks.hexagonify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hexagonify(geometries, hex_radius; kwargs...)
hexagonify(df::DataFrame, hex_radius; kwargs...) = hexagonify(df.geometry, hex_radius; kwargs...)
hexagonify(g::AbstractMetaGraph, hex_radius; kwargs...)
hexagonify(polygon::ArchGDAL.IGeometry, hex_radius; buffer=0, danger_value=10000)</code></pre><p>puts a bunch of hexagons with radius <code>hex_radius</code> in the area given by:</p><ul><li>the convex hull of a vector of <code>geometries</code>.</li><li>the convex hull of the colum titled <code>geometry</code> of a dataframe <code>df</code>.</li><li>the convex hull of the <code>:pointgeom</code> prop in the vertices of (<code>g</code>).</li><li>a <code>polygon</code>.</li></ul><p>All these things are expected to be ArchGDAL geometries.</p><p>A hexagon will be placed, if its centerpoint is within the polygon.</p><p><strong>keyword arguments</strong></p><ul><li><code>buffer</code>=0, number of times the resulting hex-grid should be buffered (that is, a layer of hexagons added to the outside) after filling the geometry.</li><li><code>danger_value</code>=10000 if the approximated number of hexagons is larger than this value, we will throw an assertion error. This is to keep you from accidentally killing your repl if you forget to convert between local and global corrdinate systems.</li></ul><p>Returns a Vector of <code>Hexagons.HexagonCubic</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.hexes2polys-Tuple{Any, Any}" href="#MinistryOfCoolWalks.hexes2polys-Tuple{Any, Any}"><code>MinistryOfCoolWalks.hexes2polys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hexes2polys(hexes, hex_radius)</code></pre><p>converts a vector of <code>Hexangons.Hexagon</code> with radius <code>hex_radius</code> to a vector of <code>ArchGDAL</code> polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.hexgrid_buffer-Tuple{Any}" href="#MinistryOfCoolWalks.hexgrid_buffer-Tuple{Any}"><code>MinistryOfCoolWalks.hexgrid_buffer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hexgrid_buffer(hexes)</code></pre><p>returns a vector of all hexagons that touch at least one hexagon in <code>hexes</code>, without duplicates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/bd359f5bc344346f891bda01d8ce88a058ccda71/src/HexagonalBins.jl#L99-L104">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Routing/">« Routing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 17 July 2023 10:37">Monday 17 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
