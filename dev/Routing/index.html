<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Routing · MinistryOfCoolWalks.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://SuperGrobi.github.io/MinistryOfCoolWalks.jl/Routing/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MinistryOfCoolWalks.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../CenterlineCorrection/">Centerline correction</a></li><li><a class="tocitem" href="../ShadowIntersection/">Shadow intersections</a></li><li class="is-active"><a class="tocitem" href>Routing</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#ShadowWeight-and-conditions-on-addition-comparison"><span>ShadowWeight and conditions on addition comparison</span></a></li><li><a class="tocitem" href="#ShadowWeightsLight"><span>ShadowWeightsLight</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../HexagonalBins/">Hexagonal Binning</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Routing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Routing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/main/docs/src/Routing.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Routing"><a class="docs-heading-anchor" href="#Routing">Routing</a><a id="Routing-1"></a><a class="docs-heading-anchor-permalink" href="#Routing" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>It might be interesting to look shortest paths in out network, using different weights for each edge, based on the length in shade and sun, as well as an external parameter, which essentially weights the length of sunny parts against the length of shaded parts along every edge. Therefore, we introduce our own <code>Real</code> subtype, together with a <code>MetaGraphs.MetaWeights</code> based Weight-Matrix, which should just work in every <code>Graphs.jl</code> algorithm, which takes a Weight Matrix.</p><h2 id="ShadowWeight-and-conditions-on-addition-comparison"><a class="docs-heading-anchor" href="#ShadowWeight-and-conditions-on-addition-comparison">ShadowWeight and conditions on addition comparison</a><a id="ShadowWeight-and-conditions-on-addition-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#ShadowWeight-and-conditions-on-addition-comparison" title="Permalink"></a></h2><p>To calculate shortest paths, we need a non negative edge weight, a less-than and an addition operation with a (or possibly multiple) <code>zero</code> elements.</p><p>we use:</p><p><code>felt_length(w) = (1-w.a) * w.shade + (1+w.a) * sun</code></p><p>and</p><p><code>real_length(w) = w.shade + w.sun</code></p><p>Since we want to be able to reconstruct the <code>real_length</code> from the number <code>w</code> which has been used in the shortest path with the <code>felt_length</code> function, we additionally need the addition with zero to be invariant under both length operations (this needs to hold for every operation you might want to do on the results from routing with a custom <code>felt_length</code>). That is:</p><p><code>felt_length(w + zero) == felt_length(w) =&gt; real_length(w + zero) == real_length(w)</code></p><p>we archieve this by constraining <code>a in (-1.0, 1.0)</code>, rather than <code>a in [-1.0, 1.0]</code>. In this way, a <code>zero</code> is of length 0 under both operations.</p><p>Applying this constraint can be argued in multiple ways: (here in German. TODO: translate this...)</p><ol><li>Das Problem betrachtend: dieses a skaliert die relative länge der schatten zu den sonnenwegen. Bedeutet in meiner Story fühlt sich Schatten (1-a)/(1+a) länger an als Sonne. Und für a = 1 bedeutet dass, das sich Schatten 0 mal länger anfühlt, und für a=-1 ist das ding nicht mal definiert, aber bedeutet sowas wie, das sich Schatten unendlich viel länger anfühlt als Sonne, was, gegeben die Problemstellung, irgendwie nicht wirklich Sinn ergibt. In beiden Fällen würde das bedeuten, das es dir egal ist wie weit du läufst, wenn du dich zwischen verschiedenen kanten mit nur sonne oder nur schatten entscheiden musst. Und das ist irgendwie nicht sinnvoll. (besser wäre es, grenzwerte <code>lim a -&gt; 1.0</code> und <code>lim a -&gt; -1.0</code> zu betrachten.)</li><li>Algorithmisch: wenn ich die wahl zwischen verschiedenen strecken die nur in der sonne oder nur im schatten sind, (die jeweils eine gefühlte länge von null haben), dann ist es von der implementation abhängig, welchen dieser wege ich nehme. Die Tatsächliche Länge die ich aus diesen pfaden ausrechnen kann, ist also nicht sehr aussagekräftig, weil ich nicht weiß welche der (sehr tatsächlich sehr unterschiedlich langen) strecken mit gefühlter länge der algorithmus genommen hat. (sprich: wenn viele kanten gefühlte länge null haben, dann gibt es viele “kürzeste wege”, und ich bekomme halt nur einen davon, und welcher ist random)</li><li>Mathematisch: für kürzesten pfad brauche ich die beiden funktionen (min, +), und + muss ein nullelement haben. Wenn ich -1 und 1 zulasse, dann gibt es aber für diese werte sehr viele nullelemente für die addition (unter der gefühlten länge), was erstmal kein problem ist, aber, wenn ich dann die reale länge ausrechne, dann sind die halt nicht mehr alle nullelemente. Und dann ist es wieder abhängig vom algorithmus, wie oft ich (gefühlte) nullen addiere, was ich für eine reale länge bekomme.</li></ol><p>Und die dinge gehen alle weg, wenn ich einfach a in (-1.0, 1.0) fordere.</p><h2 id="ShadowWeightsLight"><a class="docs-heading-anchor" href="#ShadowWeightsLight">ShadowWeightsLight</a><a id="ShadowWeightsLight-1"></a><a class="docs-heading-anchor-permalink" href="#ShadowWeightsLight" title="Permalink"></a></h2><p>faster, but less flexible version of a custom weight matrix. Used in the same way as <code>ShadowWeights</code>, but the resulting <code>PathState</code> only gives the distances in felt lengths. To get the lengths in shadow an in the sun, we need to <code>reevaluate_distances</code> with a user supplied weight matrix. (Usually <code>weights(g)</code>) will work here. This gives the lengths of the paths in real world lengths. If we need to calculate the distances in shade and sun, we can either reevaluate the distances at a different values of a and solve the different felt weights for shade and sun, or we simply reevaluate the distances twice, once with a weightmatrix where only the shadows are weights, and once where only the sunny parts are weights.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><ul><li><a href="#MinistryOfCoolWalks.ShadowWeight"><code>MinistryOfCoolWalks.ShadowWeight</code></a></li><li><a href="#MinistryOfCoolWalks.ShadowWeights"><code>MinistryOfCoolWalks.ShadowWeights</code></a></li><li><a href="#MinistryOfCoolWalks.ShadowWeights-Tuple{MetaGraphs.AbstractMetaGraph, Any}"><code>MinistryOfCoolWalks.ShadowWeights</code></a></li><li><a href="#MinistryOfCoolWalks.ShadowWeightsLight-Tuple{MetaGraphs.AbstractMetaGraph, Any}"><code>MinistryOfCoolWalks.ShadowWeightsLight</code></a></li><li><a href="#MinistryOfCoolWalks.ShadowWeightsLight"><code>MinistryOfCoolWalks.ShadowWeightsLight</code></a></li><li><a href="#Base.:+-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}"><code>Base.:+</code></a></li><li><a href="#Base.:&lt;-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}"><code>Base.:&lt;</code></a></li><li><a href="#Base.:==-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}"><code>Base.:==</code></a></li><li><a href="#Base.getindex-Union{Tuple{T}, Tuple{U}, Tuple{ShadowWeightsLight{T, U}, Integer, Integer}} where {U&lt;:Real, T&lt;:Integer}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{ShadowWeights, Integer, Integer}"><code>Base.getindex</code></a></li><li><a href="#Base.size-Tuple{ShadowWeights}"><code>Base.size</code></a></li><li><a href="#Base.size-Tuple{ShadowWeightsLight}"><code>Base.size</code></a></li><li><a href="#Base.typemax-Tuple{MinistryOfCoolWalks.ShadowWeight}"><code>Base.typemax</code></a></li><li><a href="#Base.zero-Tuple{MinistryOfCoolWalks.ShadowWeight}"><code>Base.zero</code></a></li><li><a href="#Graphs.johnson_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{Graphs.AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:MinistryOfCoolWalks.ShadowWeight}"><code>Graphs.johnson_shortest_paths</code></a></li><li><a href="#MinistryOfCoolWalks.felt_length-Tuple{MinistryOfCoolWalks.ShadowWeight}"><code>MinistryOfCoolWalks.felt_length</code></a></li><li><a href="#MinistryOfCoolWalks.get_path_length-Tuple{Any, Any}"><code>MinistryOfCoolWalks.get_path_length</code></a></li><li><a href="#MinistryOfCoolWalks.real_length-Tuple{MinistryOfCoolWalks.ShadowWeight}"><code>MinistryOfCoolWalks.real_length</code></a></li><li><a href="#MinistryOfCoolWalks.reevaluate_distances-Tuple{Any, Any}"><code>MinistryOfCoolWalks.reevaluate_distances</code></a></li><li><a href="#MinistryOfCoolWalks.reevaluate_distances_slow-Tuple{Any, Any}"><code>MinistryOfCoolWalks.reevaluate_distances_slow</code></a></li><li><a href="#MinistryOfCoolWalks.to_SimpleWeightedDiGraph"><code>MinistryOfCoolWalks.to_SimpleWeightedDiGraph</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.ShadowWeight" href="#MinistryOfCoolWalks.ShadowWeight"><code>MinistryOfCoolWalks.ShadowWeight</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShadowWeight(a::Float64, shade::Float64, sun::Float64) &lt;: Real</code></pre><p>Typ representing the weight on one edge.</p><ul><li><code>a</code> represents the preference for shadow or sun, where <code>a==0.0</code> signifies indifference, <code>a ∈ (0.0, 1.0)</code> favours shaded edges,</li></ul><p>and <code>a ∈ (-1.0, 0.0)</code> favours sunny edges. Value must be in <code>(-1.0, 1.0)</code>, otherwise, an Error is thrown.</p><ul><li><code>shade</code> represents the (real world) length of the edge in shade. Has to be non-negative, otherwise, an Error is thrown.</li><li><code>sun</code> represents the (real world) length of the edge in the sun. Has to be non-negative, otherwise, an Error is thrown.</li><li>if shade or sun is <code>Inf</code>, the other value has to be <code>Inf</code> as well, otherwise, an error is thrown.</li></ul><p>This also means, that <code>shade+sun=real_world_street_length</code>.</p><pre><code class="nohighlight hljs">unsafe_ShadowWeight(a, shade, sun)</code></pre><p>unsafe constructor for <code>ShadowWeight</code>, does not validate the inputs, used internally when we know that all conditions are fulfilled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.ShadowWeights" href="#MinistryOfCoolWalks.ShadowWeights"><code>MinistryOfCoolWalks.ShadowWeights</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShadowWeights{T&lt;:Integer,U&lt;:Real} &lt;: AbstractMatrix{ShadowWeight}</code></pre><p>Abstract Matrix type of <code>ShadowWeight</code>s, usable as weights in graph-algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.ShadowWeights-Tuple{MetaGraphs.AbstractMetaGraph, Any}" href="#MinistryOfCoolWalks.ShadowWeights-Tuple{MetaGraphs.AbstractMetaGraph, Any}"><code>MinistryOfCoolWalks.ShadowWeights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ShadowWeights(a, full_weights::I, shadow_weights::I) where {T&lt;:Integer,U&lt;:Real,I&lt;:MetaGraphs.MetaWeights{T,U}}</code></pre><p>Base constructor for <code>ShadowWeights</code>. <code>a</code> has to be in <code>(-1.0, 1.0)</code>, otherwise an error will be thrown. <code>full_weights</code> and <code>shadow_weights</code> are the full lengths of the edges and the length of these edges in shadow, respectively. Make sure that <code>all(shadow_weights .&lt;= full_weights</code>) == true<code>for all edges which exist, otherwise, the results might not be what you expect. Constructor checks that</code>maximum(shadow<em>weights)&lt;typemax(U)<code>and</code>maximum(full</em>weights)&lt;typemax(U)`. (TODO: Maybe there is a faster way of doing this?)</p><pre><code class="nohighlight hljs">ShadowWeights(g::AbstractMetaGraph, a; shadow_source=:shadowed_length)</code></pre><p>Constructs the <code>ShadowWeights</code> from a <code>MetaGraph</code> and the <code>a</code> value. (See the docs of <code>ShadowWeight</code> for an explanation of the parameter.)</p><p>Assumes that <code>weightfield(g)</code> encodes the full length of each edge. Additionally, it is possible to set the field from which the length of the shadows will be extracted. The default value is <code>:shadowed_length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L138-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.ShadowWeightsLight" href="#MinistryOfCoolWalks.ShadowWeightsLight"><code>MinistryOfCoolWalks.ShadowWeightsLight</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShadowWeightsLight{T&lt;:Integer,U&lt;:Real} &lt;: AbstractMatrix{U}</code></pre><p>AbstractMatrix type, usable in graph algorithms, alternative approach to using <code>ShadowWeights</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.ShadowWeightsLight-Tuple{MetaGraphs.AbstractMetaGraph, Any}" href="#MinistryOfCoolWalks.ShadowWeightsLight-Tuple{MetaGraphs.AbstractMetaGraph, Any}"><code>MinistryOfCoolWalks.ShadowWeightsLight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ShadowWeightsLight(a, geom_weights::I, shadow_weights::I) where {T&lt;:Integer,U&lt;:Real,I&lt;:MetaGraphs.MetaWeights{T,U}}</code></pre><p>Base constructor for <code>ShadowWeightsLight</code>. <code>a</code> has to be in <code>(-1.0, 1.0)</code>, otherwise an error will be thrown. <code>geom_weights</code> and <code>shadow_weights</code> are the full lengths of the edges and the length of these edges in shadow, respectively. Make sure that <code>all(shadow_weights .&lt;= geom_weights) == true</code>, otherwise, the results might not be what you expect. Constructor checks that <code>maximum(shadow_weights)&lt;typemax(U)</code> and <code>maximum(full_weights)&lt;typemax(U)</code>. (TODO: Maybe there is a faster way of doing this?)</p><pre><code class="nohighlight hljs">ShadowWeightsLight(g::AbstractMetaGraph, a; shadow_source=:shadowed_length)</code></pre><p>Constructs the <code>ShadowWeightsLight</code> from a <code>MetaGraph</code> and the <code>a</code> value. (See <code>getindex(m::ShadowWeightsLight, ...)</code> for an explanation of this parameter.)</p><p>Assumes that <code>weightfield(g)</code> encodes the full length of each edge. Additionally, it is possible to set the field from which the length of the shadows will be extracted. The default value is <code>:shadowed_length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L251-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}" href="#Base.:+-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(a::ShadowWeight, b::ShadowWeight)</code></pre><p>Two general <code>ShadowWeight</code>s are addable, if their <code>a</code> fields match. The result is a new <code>ShadowWeight</code> with the same <code>a</code> value and the sum of the <code>sun</code> and <code>shadow</code> fields of both <code>ShadowWeights</code>. The return value is generated using <code>unsafe_ShadowWeight</code> due to performance considerations. Make sure that you only input valid <code>ShadowWeight</code>s.</p><p>Special care has to be taken when adding values which identify with either zero or infinity. In this case, we ignore the condition of the <code>a</code> fields having to be the same and return just the appropriate input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L88-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}" href="#Base.:&lt;-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}"><code>Base.:&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;(a::ShadowWeight, b::ShadowWeight)</code></pre><p>a <code>ShadowWeight</code> is less than another, if its <code>felt_length</code> is less than the one of the other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}" href="#Base.:==-Tuple{MinistryOfCoolWalks.ShadowWeight, MinistryOfCoolWalks.ShadowWeight}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(a::ShadowWeight, b::ShadowWeight)</code></pre><p>Two <code>ShadowWeight</code>s are the considered equal, if their <code>felt_length</code>s are the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{ShadowWeights, Integer, Integer}" href="#Base.getindex-Tuple{ShadowWeights, Integer, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(w::ShadowWeights, u::Integer, v::Integer)</code></pre><p>Get the <code>ShadowWeight</code> at index <code>u,v</code>. The length in the sun is calculated as <code>abs(full_length-shadow_length)</code>, to account for numerical deviations where the edge might be slightly shorter than the shadow covering it. If the length in the shade is systematically longer than the full edge, this will not Error, but fail silently. Since we check the maximum values on construction, we can use <code>unsafe_ShadowWeight</code> to create the return value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L168-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{U}, Tuple{ShadowWeightsLight{T, U}, Integer, Integer}} where {U&lt;:Real, T&lt;:Integer}" href="#Base.getindex-Union{Tuple{T}, Tuple{U}, Tuple{ShadowWeightsLight{T, U}, Integer, Integer}} where {U&lt;:Real, T&lt;:Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(w::ShadowWeightsLight{T,U}, u::Integer, v::Integer)::U where {T&lt;:Integer} where {U&lt;:Real}</code></pre><p>Get the length of an edge from u to v in the <code>felt_length</code>, defined as:</p><p><code>(1 - w.a) * shadow_length + (1 + w.a) * sun_length</code>. <code>a</code> represents the preference for shadow or sun, where <code>a==0.0</code> signifies indifference, <code>a ∈ (0.0, 1.0)</code> favours shaded edges, and <code>a ∈ (-1.0, 0.0)</code> favours sunny edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L276-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{ShadowWeightsLight}" href="#Base.size-Tuple{ShadowWeightsLight}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(x::ShadowWeightsLight)</code></pre><p>size of <code>ShadowWeightsLight</code> is size of geometry weights contained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{ShadowWeights}" href="#Base.size-Tuple{ShadowWeights}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(x::ShadowWeights)</code></pre><p>The size of a <code>ShadowWeights</code> is the size of the <code>full_weights</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.typemax-Tuple{MinistryOfCoolWalks.ShadowWeight}" href="#Base.typemax-Tuple{MinistryOfCoolWalks.ShadowWeight}"><code>Base.typemax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typemax(x::ShadowWeight) = typemax(typeof(x))
typemax(::Type{ShadowWeight})</code></pre><p>returns the maximum value associated with the <code>ShadowWeight</code> Real. Equivalent to <code>ShadowWeight(0.0, Inf, Inf)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Tuple{MinistryOfCoolWalks.ShadowWeight}" href="#Base.zero-Tuple{MinistryOfCoolWalks.ShadowWeight}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero(x::ShadowWeight)
zero(::Type{ShadowWeight})</code></pre><p>returns the zero value associated with the <code>ShadowWeight</code> Real. Equivalent to <code>ShadowWeight(0.0, 0.0, 0.0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.johnson_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{Graphs.AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:MinistryOfCoolWalks.ShadowWeight}" href="#Graphs.johnson_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{Graphs.AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:MinistryOfCoolWalks.ShadowWeight}"><code>Graphs.johnson_shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Graphs.johnson_shortest_paths(g::AbstractGraph{U}, distmx::AbstractMatrix{T}) where {U&lt;:Integer,T&lt;:ShadowWeight}</code></pre><p>version of <code>johnson_shortest_paths</code> for <code>distmx</code> with <code>ShadowWeight</code> as entries, since we can not subtract these. Converts the graph and weights to <code>SimpleWeightedDiGraph</code>, to speed up the calculation and abstract away the complexity. (In reality, this is just a bunch of <code>dijkstra_shortest_paths</code>, wrapped to return a <code>JohnsonState</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L204-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.felt_length-Tuple{MinistryOfCoolWalks.ShadowWeight}" href="#MinistryOfCoolWalks.felt_length-Tuple{MinistryOfCoolWalks.ShadowWeight}"><code>MinistryOfCoolWalks.felt_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">felt_length(w::ShadowWeight)</code></pre><p>returns the felt length of a <code>ShadowWeight</code>. It is defined as: <code>(1 - a) * shade + (1 + a) * sun</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.get_path_length-Tuple{Any, Any}" href="#MinistryOfCoolWalks.get_path_length-Tuple{Any, Any}"><code>MinistryOfCoolWalks.get_path_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_path_length(path, weights)</code></pre><p>function to calculate the length of a path given by a vector of node ids in a externally supplied weight matrix. (Not exported, mainly used in Testing.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L355-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.real_length-Tuple{MinistryOfCoolWalks.ShadowWeight}" href="#MinistryOfCoolWalks.real_length-Tuple{MinistryOfCoolWalks.ShadowWeight}"><code>MinistryOfCoolWalks.real_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real_length(w::ShadowWeight)</code></pre><p>returns the real length of a <code>ShadowWeight</code>. (That is: <code>sun+shade</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.reevaluate_distances-Tuple{Any, Any}" href="#MinistryOfCoolWalks.reevaluate_distances-Tuple{Any, Any}"><code>MinistryOfCoolWalks.reevaluate_distances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reevaluate_distances(state, weights)</code></pre><p>reevaluates the shortest paths in state with the given weight matrix. This function is neccessary  since the approach with <code>ShadowWeightsLight</code> weights only returns the felt lengths. To make these values comparable, we need the path lengths under the same weight matrix. This algorithm works only for <code>FloydWarshallState</code>s, as it uses a modified floyd warshall algorithm to do so.</p><p>Please note that the results from this algorithm might vary from the results which can be obtained from other implementations of this reevaluation (mainly <code>reevaluate_distances_slow</code>), if there exist multiple shortest paths in the felt measure. In this, faster implementation, the one that ends up getting picked for the real length depends on the order in which the nodes are checked. But the routing output does so as well, so on average, we should be fine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L302-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.reevaluate_distances_slow-Tuple{Any, Any}" href="#MinistryOfCoolWalks.reevaluate_distances_slow-Tuple{Any, Any}"><code>MinistryOfCoolWalks.reevaluate_distances_slow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reevaluate_distances_slow(state, weights)</code></pre><p>recalculates the lengths of the paths encoded in <code>state</code> using the supplied <code>weights</code> matrix. (Not exported, mainly used in Testing, since very slow.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L363-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinistryOfCoolWalks.to_SimpleWeightedDiGraph" href="#MinistryOfCoolWalks.to_SimpleWeightedDiGraph"><code>MinistryOfCoolWalks.to_SimpleWeightedDiGraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_SimpleWeightedDiGraph(g, distmx)</code></pre><p>converts graph <code>g</code> with weights in <code>distmx</code> into <code>SimpleWeightedDiGraph</code> with weights from distmx.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/MinistryOfCoolWalks.jl/blob/f7b0a218dfffa2fc7885e4c8ac20adbfdbc65cba/src/Routing.jl#L183-L188">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ShadowIntersection/">« Shadow intersections</a><a class="docs-footer-nextpage" href="../HexagonalBins/">Hexagonal Binning »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 21 April 2023 12:23">Friday 21 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
