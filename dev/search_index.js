var documenterSearchIndex = {"docs":
[{"location":"Routing/#Routing","page":"Routing","title":"Routing","text":"","category":"section"},{"location":"Routing/#Introduction","page":"Routing","title":"Introduction","text":"","category":"section"},{"location":"Routing/","page":"Routing","title":"Routing","text":"It might be interesting to look shortest paths in out network, using different weights for each edge, based on the length in shade and sun, as well as an external parameter, which essentially weights the length of sunny parts against the length of shaded parts along every edge. Therefore, we introduce our own Real subtype, together with a MetaGraphs.MetaWeights based Weight-Matrix, which should just work in every Graphs.jl algorithm, which takes a Weight Matrix.","category":"page"},{"location":"Routing/#ShadowWeight-and-conditions-on-addition-and-comparison","page":"Routing","title":"ShadowWeight and conditions on addition and comparison","text":"","category":"section"},{"location":"Routing/","page":"Routing","title":"Routing","text":"To calculate shortest paths, we need a non negative edge weight, a less-than and an addition operation with a (or possibly multiple) zero elements.","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"we use:","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"felt_length(w) = w.shade + w.a * sun","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"and","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"real_length(w) = w.shade + w.sun","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"Since we want to be able to reconstruct the real_length from the number w which has been used in the shortest path with the felt_length function, we additionally need the addition with zero to be invariant under both length operations (this needs to hold for every operation you might want to do on the results from routing with a custom felt_length). That is:","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"felt_length(w + zero) == felt_length(w) => real_length(w + zero) == real_length(w)","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"we archieve this by constraining a in (0.0, Inf), rather than a in [0.0, Inf). In this way, a zero is of length 0 under both operations.","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"Our zero element takes the form of ShadowWeight(a, 0.0, 0.0) with an arbitrary a as constrained above.","category":"page"},{"location":"Routing/#API","page":"Routing","title":"API","text":"","category":"section"},{"location":"Routing/","page":"Routing","title":"Routing","text":"Pages = [\"Routing.md\"]","category":"page"},{"location":"Routing/","page":"Routing","title":"Routing","text":"Modules = [MinistryOfCoolWalks]\nPages = [\"Routing.jl\"]","category":"page"},{"location":"Routing/#MinistryOfCoolWalks.ShadowWeight","page":"Routing","title":"MinistryOfCoolWalks.ShadowWeight","text":"ShadowWeight(a::Float64, shade::Float64, sun::Float64) <: Real\n\nType representing the weight on one edge.\n\na represents the preference for shadow or sun, where a==1.0 signifies indifference, a ∈ (1.0, Inf) favours shaded edges,\n\nand a ∈ (0.0, 1.0) favours sunny edges. Value must be in (0.0, Inf), otherwise, an Error is thrown.\n\nshade represents the (real world) length of the edge in shade. Has to be non-negative, otherwise, an Error is thrown.\nsun represents the (real world) length of the edge in the sun. Has to be non-negative, otherwise, an Error is thrown.\nif shade or sun is Inf, the other value has to be Inf as well, otherwise, an error is thrown.\n\nThis also means, that shade+sun=real_world_street_length.\n\nunsafe_ShadowWeight(a, shade, sun)\n\nunsafe constructor for ShadowWeight, does not validate the inputs, used internally when we know that all conditions are fulfilled.\n\n\n\n\n\n","category":"type"},{"location":"Routing/#MinistryOfCoolWalks.ShadowWeights","page":"Routing","title":"MinistryOfCoolWalks.ShadowWeights","text":"ShadowWeights{T<:Integer,U<:Real} <: AbstractMatrix{ShadowWeight}\n\nAbstract Matrix type with elements of ShadowWeights, usable as weights in graph-algorithms.\n\n\n\n\n\n","category":"type"},{"location":"Routing/#MinistryOfCoolWalks.ShadowWeights-Tuple{MetaGraphs.AbstractMetaGraph, Any}","page":"Routing","title":"MinistryOfCoolWalks.ShadowWeights","text":"ShadowWeights(a, street_weights::I, shadow_weights::I) where {T<:Integer,U<:Real,I<:MetaGraphs.MetaWeights{T,U}}\n\nBase constructor for ShadowWeights. a has to be in (0.0, Inf), otherwise an error will be thrown. street_weights and shadow_weights are the lengths of the streets and the lengths of shadow on these streets, respectively. Make sure that all(shadow_weights .<= street_weights) == true for all edges which exist, otherwise, the results might not be what you expect. Constructor checks that maximum(shadow_weights)<typemax(U) and maximum(street_weights)<typemax(U).\n\nShadowWeights(g::AbstractMetaGraph, a; shadow_source=:sg_shadow_length)\n\nConstructs the ShadowWeights from a MetaGraph and the a value. (See the docs of ShadowWeight for an explanation of the parameter.)\n\nAssumes that weightfield(g) encodes the full length of each street. Additionally, it is possible to set the field from which the length of the shadows will be extracted. The default value is :sg_shadow_length.\n\n\n\n\n\n","category":"method"},{"location":"Routing/#MinistryOfCoolWalks.SymmetricShadowWeights","page":"Routing","title":"MinistryOfCoolWalks.SymmetricShadowWeights","text":"SymmetricShadowWeights{T<:Integer,U<:Real} <: AbstractMatrix{ShadowWeight}\n\nAbstract Matrix type with elements of ShadowWeights, usable as weights in graph-algorithms. Always returns the smaller weight: distmx[i,j] = min(distmx[i,j], distmx[j,i]) if both directions exist. Otherwise, returns the existing one.\n\n\n\n\n\n","category":"type"},{"location":"Routing/#Base.:*-Tuple{AbstractFloat, ShadowWeight}","page":"Routing","title":"Base.:*","text":"*(a::AbstractFloat, b::ShadowWeight)\n*(a::ShadowWeight, b::AbstractFloat)\n\nMultiplication with Float. Scales shade and sun.\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.:*-Tuple{Integer, ShadowWeight}","page":"Routing","title":"Base.:*","text":"*(a::Integer, b::ShadowWeight)\n*(a::ShadowWeight, b::Integer)\n\nMultiplication with Integer. Scales shade and sun.\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.:*-Tuple{ShadowWeight, Bool}","page":"Routing","title":"Base.:*","text":"*(a::ShadowWeight, b::Bool)\n*(a::Bool, b::ShadowWeight)\n\nMultiplication with Boolean. Returns a if b is true, otherwise zero(ShadowWeight).\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.:+-Tuple{ShadowWeight, ShadowWeight}","page":"Routing","title":"Base.:+","text":"+(a::ShadowWeight, b::ShadowWeight)\n\nTwo general ShadowWeights are addable, if their a fields match. The result is a new ShadowWeight with the same a value and the sum of the sun and shadow fields of both ShadowWeights. The return value is generated using unsafe_ShadowWeight due to performance considerations. Make sure that you only input valid ShadowWeights.\n\nSpecial care has to be taken when adding values which identify with either zero or infinity. In this case, we ignore the condition of the a fields having to be the same and return just the appropriate input.\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.:<-Tuple{ShadowWeight, ShadowWeight}","page":"Routing","title":"Base.:<","text":"<(a::ShadowWeight, b::ShadowWeight)\n\na ShadowWeight is less than another, if its felt_length is less than the one of the other.\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.:==-Tuple{ShadowWeight, ShadowWeight}","page":"Routing","title":"Base.:==","text":"==(a::ShadowWeight, b::ShadowWeight)\n\nTwo ShadowWeights are the considered equal, if their felt_lengths are the same.\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.getindex-Tuple{ShadowWeights, Integer, Integer}","page":"Routing","title":"Base.getindex","text":"getindex(w::ShadowWeights, u::Integer, v::Integer)\n\nGet the ShadowWeight at index u,v. The length in the sun is calculated as abs(street_length-shadow_length), to account for numerical deviations where the edge might be slightly shorter than the shadow covering it. If the length in the shade is systematically longer than the full edge, this will not Error, but fail silently. Since we check the maximum values on construction, we can use unsafe_ShadowWeight to create the return value.\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.size-Tuple{ShadowWeights}","page":"Routing","title":"Base.size","text":"size(x::ShadowWeights)\n\nThe size of a ShadowWeights is the size of the street_weights field.\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.typemax-Tuple{ShadowWeight}","page":"Routing","title":"Base.typemax","text":"typemax(x::ShadowWeight) = typemax(typeof(x))\ntypemax(::Type{ShadowWeight})\n\nreturns the maximum value associated with the ShadowWeight Real. Equivalent to ShadowWeight(1.0, Inf, Inf)\n\n\n\n\n\n","category":"method"},{"location":"Routing/#Base.zero-Tuple{ShadowWeight}","page":"Routing","title":"Base.zero","text":"zero(x::ShadowWeight)\nzero(::Type{ShadowWeight})\n\nreturns the zero value associated with the ShadowWeight Real. Equivalent to ShadowWeight(1.0, 0.0, 0.0).\n\n\n\n\n\n","category":"method"},{"location":"Routing/#MinistryOfCoolWalks.felt_length-Tuple{ShadowWeight}","page":"Routing","title":"MinistryOfCoolWalks.felt_length","text":"felt_length(w::ShadowWeight)\n\nreturns the felt length of a ShadowWeight. It is defined as: a * sun + shade\n\n\n\n\n\n","category":"method"},{"location":"Routing/#MinistryOfCoolWalks.get_path_length-Tuple{Any, Any}","page":"Routing","title":"MinistryOfCoolWalks.get_path_length","text":"get_path_length(path, weights)\n\nfunction to calculate the length of a path given by a vector of node ids in a externally supplied weight matrix. (Not exported, only used in Testing.)\n\n\n\n\n\n","category":"method"},{"location":"Routing/#MinistryOfCoolWalks.real_length-Tuple{ShadowWeight}","page":"Routing","title":"MinistryOfCoolWalks.real_length","text":"real_length(w::ShadowWeight)\n\nreturns the real length of a ShadowWeight. (That is: sun+shade).\n\n\n\n\n\n","category":"method"},{"location":"Routing/#MinistryOfCoolWalks.reevaluate_distances-Tuple{Any, Any}","page":"Routing","title":"MinistryOfCoolWalks.reevaluate_distances","text":"reevaluate_distances(state, weights)\n\nreevaluates the shortest paths in state with the given weight matrix. This function is used for testing. This algorithm works only for FloydWarshallStates, as it uses a modified floyd warshall algorithm to do so.\n\nPlease note that the results from this algorithm might vary from the results which can be obtained from other implementations of this reevaluation (mainly reevaluate_distances_slow), if there exist multiple shortest paths in the felt measure. In this, faster implementation, the one that ends up getting picked for the real length depends on the order in which the nodes are checked. But the routing output does so as well, so on average, we should be fine. (Not exported, only used in Testing.)\n\n\n\n\n\n","category":"method"},{"location":"Routing/#MinistryOfCoolWalks.reevaluate_distances_slow-Tuple{Any, Any}","page":"Routing","title":"MinistryOfCoolWalks.reevaluate_distances_slow","text":"reevaluate_distances_slow(state, weights)\n\nrecalculates the lengths of the paths encoded in state using the supplied weights matrix. (Not exported, only used in Testing, since very slow.)\n\n\n\n\n\n","category":"method"},{"location":"RoutingMeasures/#Measures-based-on-routing-on-Graphs","page":"Routing based Measures","title":"Measures based on routing on Graphs","text":"","category":"section"},{"location":"RoutingMeasures/#Introduction","page":"Routing based Measures","title":"Introduction","text":"","category":"section"},{"location":"RoutingMeasures/","page":"Routing based Measures","title":"Routing based Measures","text":"These are a bunch of helper functions to calculate any kind of measures based on routing on the graph Most of this stuff should actually be (and is, but not yet released...) in Graphs.jl.","category":"page"},{"location":"RoutingMeasures/#API","page":"Routing based Measures","title":"API","text":"","category":"section"},{"location":"RoutingMeasures/","page":"Routing based Measures","title":"Routing based Measures","text":"Pages = [\"RoutingMeasures.md\"]","category":"page"},{"location":"RoutingMeasures/","page":"Routing based Measures","title":"Routing based Measures","text":"Modules = [MinistryOfCoolWalks]\nPages = [\"RoutingMeasures.jl\"]","category":"page"},{"location":"RoutingMeasures/#Graphs.johnson_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{Graphs.AbstractGraph{U}, AbstractMatrix{T}}} where {U<:Integer, T<:ShadowWeight}","page":"Routing based Measures","title":"Graphs.johnson_shortest_paths","text":"Graphs.johnson_shortest_paths(g::AbstractGraph{U}, distmx::AbstractMatrix{T}; max_length=typemax(T)) where {U<:Integer,T<:ShadowWeight}\n\nversion of johnson_shortest_paths for distmx with ShadowWeight as entries, since we can not subtract these. Converts the graph and weights to SimpleWeightedDiGraph (while making sure that zero length edges are not dropped (see to_SimpleWeightedDiGraph)), to speed up the calculation and abstract away the complexity. (In reality, this is just a bunch of early_stopping_dijkstra, wrapped to return a JohnsonState).\n\n\n\n\n\n","category":"method"},{"location":"RoutingMeasures/#MinistryOfCoolWalks.betweenness_centralities-Union{Tuple{T}, Tuple{Graphs.DijkstraState, T}} where T<:Integer","page":"Routing based Measures","title":"MinistryOfCoolWalks.betweenness_centralities","text":"betweenness_centralities(state, start)\n\nCalculates the node and edge betweennesses encoded in the dijkstra state, with shortest paths from s. Assumes all paths to be unique (does not use to state.predecessors) field. Does not include the endpoints, and is not normalised. Most of this code was taken from the Graphs.jl betweenness_centrality implementation.\n\n\n\n\n\n","category":"method"},{"location":"RoutingMeasures/#MinistryOfCoolWalks.early_stopping_dijkstra-Union{Tuple{U}, Tuple{T}, Tuple{Graphs.AbstractGraph, U}, Tuple{Graphs.AbstractGraph, U, AbstractMatrix{T}}} where {T<:Real, U<:Integer}","page":"Routing based Measures","title":"MinistryOfCoolWalks.early_stopping_dijkstra","text":"early_stopping_dijkstra(g::AbstractGraph, s::U, distmx::AbstractMatrix{T}=weights(g); max_length::T=typemax(T)) where {T<:Real,U<:Integer}\n\nCalculates dijkstras shortest paths, but treats edges which would make the shortest path longer than max_length as non-existent.\n\nNearly all of this code was taken from the Graphs.jl dijkstra implementation.\n\nBehaves like dijkstra_shortest_paths(g, i; trackvertices=true), if all other arguments are omitted.\n\n\n\n\n\n","category":"method"},{"location":"RoutingMeasures/#MinistryOfCoolWalks.edges_visited-Tuple{Graphs.DijkstraState, Any}","page":"Routing based Measures","title":"MinistryOfCoolWalks.edges_visited","text":"edges_visited(parents::AbstractArray, reachables::BitArray)\nedges_visited(state::Graphs.DijkstraState, reachables::BitArray)\n\nEfficiently calculates all the edges traversed by the paths, considering only destinations i where reachables[i]==true.\n\n\n\n\n\n","category":"method"},{"location":"RoutingMeasures/#MinistryOfCoolWalks.to_SimpleWeightedDiGraph","page":"Routing based Measures","title":"MinistryOfCoolWalks.to_SimpleWeightedDiGraph","text":"to_SimpleWeightedDiGraph(g, distmx)\n\nconverts directed graph g with weights in distmx into SimpleWeightedDiGraph with weights from distmx. Due to the way we construct it here, edges with zero length are kept as structural nonzeros in the SWG.\n\n\n\n\n\n","category":"function"},{"location":"HexagonalBins/#Hexagonal-Bins","page":"Hexagonal Binning","title":"Hexagonal Bins","text":"","category":"section"},{"location":"HexagonalBins/#Introduction","page":"Hexagonal Binning","title":"Introduction","text":"","category":"section"},{"location":"HexagonalBins/","page":"Hexagonal Binning","title":"Hexagonal Binning","text":"These utilities can be used to aggregate arbitrary spatial properties into hexagonal areas. Might be useful. Note that these functions are lacking tests.","category":"page"},{"location":"HexagonalBins/#API","page":"Hexagonal Binning","title":"API","text":"","category":"section"},{"location":"HexagonalBins/","page":"Hexagonal Binning","title":"Hexagonal Binning","text":"Pages = [\"HexagonalBins.md\"]","category":"page"},{"location":"HexagonalBins/","page":"Hexagonal Binning","title":"Hexagonal Binning","text":"Modules = [MinistryOfCoolWalks]\nPages = [\"HexagonalBins.jl\"]","category":"page"},{"location":"HexagonalBins/#MinistryOfCoolWalks.get_crs_for_hexagons-Tuple{DataFrames.DataFrame}","page":"Hexagonal Binning","title":"MinistryOfCoolWalks.get_crs_for_hexagons","text":"get_crs_for_hexagons(df::DataFrame)\nget_crs_for_hexagons(g::AbstractMetaGraph)\n\nunified interface for accessing the local coordinate system of dataframes and graphs that support it.\n\n\n\n\n\n","category":"method"},{"location":"HexagonalBins/#MinistryOfCoolWalks.hex_center-Tuple{Hexagons.Hexagon, Any}","page":"Hexagonal Binning","title":"MinistryOfCoolWalks.hex_center","text":"hex_center(hex::Hexagons.Hexagon, r)\n\ncaculates the centerpoint of the hex with radius r. Returns an ArchGDAL point.\n\n\n\n\n\n","category":"method"},{"location":"HexagonalBins/#MinistryOfCoolWalks.hexagon_area-Tuple{Any, Any}","page":"Hexagonal Binning","title":"MinistryOfCoolWalks.hexagon_area","text":"hexagon_area(dx, dy)\n\narea of a hexagon with radius 1, that is scaled by dx in x direction, and by dy in y direction.\n\n\n\n\n\n","category":"method"},{"location":"HexagonalBins/#MinistryOfCoolWalks.hexagon_histogram-Tuple{Any, Any, Any}","page":"Hexagonal Binning","title":"MinistryOfCoolWalks.hexagon_histogram","text":"hexagon_histogram(aggregator, geom_source, radius; buffer=0, danger_value=10000, filter_values=x -> true)\n\ncalculates the \"generalised histogram\" for data in a DataFrame or MetaGraph. For both these types, we expect the following methods to be implemented:\n\nproject_local!\nbuild_rtree (val should be a NamedTuple with at least the ArchGDAL.IGeometry under the keyword of orig).\nhexagonify\nget_crs_for_hexagons\nproject_back!\n\nArguments\n\naggregator: closure (actual_intersections::Vector{SpatialElem}, hexagon::ArchGDAL.IGemometry{WKBPolygon})->T, where T is the type of result in each hexagon-bin.   the first Argument is a Vector of the SpatialElements in the R-Tree of geom_source, where ArchGDAL.intersects(hexagon, intersection.val.orig)==true. The second   argument is the hexagon which is currently aggregated over.\ngeom_source: source of geometry for R-Tree (and maybe other data.), currently, DataFrame and AbstractMetaGraph are supported.\nradius: radius of hexagons in which the bins should be calculated. (Passed to hexagonify).\n\nKeyword Arguments\n\nbuffer=0: Number of times the hexagons should be buffered before the aggregation.\ndanger_value=10000: Number of predicted hexes above which hexagonify will fail.\nfilter_values=x->true: Only hexagons where the filter_values(aggregation_value)==true will be returned.\n\nProcess\n\nWe project geom_source to a local coordinate system and calculate the hexagonalisation of the area defined by it. The projected geom_source is then converted into an R-Tree. For each hexagon in the hexagonalisation we calculate the value within that hexagon using the aggregator, filter these values with filter_values, project everything back, and return only the hexagons and values where filter_values(value)==true.\n\nReturns (filtered_hexagons, filtered_values)\n\nExamples\n\nTo get the number of nodes of a ShadowGraph in each hexagon with more than 0 nodes, you can do something like this:\n\nhexes, values = hexagon_histogram(shadow_graph, 50; filter_values=(>(0))) inters, hex\n    count(i -> i.val.type == :vertex, inters)\nend\n\nTo get the total area of (possibly overlapping) buildings do:\n\nhexes, values = hexagon_histogram(buildings, 50) do inters, hex\n    geom = mapreduce(ArchGDAL.union, inters; init=ArchGDAL.createpolygon()) do i\n        ArchGDAL.intersection(hex, i.val.orig)\n    end\n    return ArchGDAL.geomarea(geom)\nend\n\n\n\n\n\n","category":"method"},{"location":"HexagonalBins/#MinistryOfCoolWalks.hexagonify-Tuple{Any, Any}","page":"Hexagonal Binning","title":"MinistryOfCoolWalks.hexagonify","text":"hexagonify(geometries, hex_radius; kwargs...)\nhexagonify(df::DataFrame, hex_radius; kwargs...) = hexagonify(df.geometry, hex_radius; kwargs...)\nhexagonify(g::AbstractMetaGraph, hex_radius; kwargs...)\nhexagonify(polygon::ArchGDAL.IGeometry, hex_radius; buffer=0, danger_value=10000)\n\nputs a bunch of hexagons with radius hex_radius in the area given by:\n\nthe convex hull of a vector of geometries.\nthe convex hull of the colum titled :geometry of a dataframe df.\nthe convex hull of the :sg_geometry prop in the vertices of (g).\na polygon.\n\nAll these things are expected to be ArchGDAL geometries.\n\nA hexagon will be placed, if its centerpoint is within the polygon.\n\nkeyword arguments\n\nbuffer=0, number of times the resulting hex-grid should be buffered (that is, a layer of hexagons added to the outside) after filling the geometry.\ndanger_value=10000 if the approximated number of hexagons is larger than this value, we will throw an assertion error. This is to keep you from accidentally killing your REPL if you forget to convert between local and global corrdinate systems.\n\nReturns a Vector of Hexagons.HexagonCubics.\n\n\n\n\n\n","category":"method"},{"location":"HexagonalBins/#MinistryOfCoolWalks.hexes2polys-Tuple{Any, Any}","page":"Hexagonal Binning","title":"MinistryOfCoolWalks.hexes2polys","text":"hexes2polys(hexes, hex_radius)\n\nconverts a vector of Hexangons.Hexagon with radius hex_radius to a vector of ArchGDAL polygons.\n\n\n\n\n\n","category":"method"},{"location":"HexagonalBins/#MinistryOfCoolWalks.hexgrid_buffer-Tuple{Any}","page":"Hexagonal Binning","title":"MinistryOfCoolWalks.hexgrid_buffer","text":"hexgrid_buffer(hexes)\n\nreturns a vector of all hexagons that touch at least one hexagon in hexes, without duplicates.\n\n\n\n\n\n","category":"method"},{"location":"ShadowIntersection/#Shadow-Itersection","page":"Shadow intersections","title":"Shadow Itersection","text":"","category":"section"},{"location":"ShadowIntersection/#Introduction","page":"Shadow intersections","title":"Introduction","text":"","category":"section"},{"location":"ShadowIntersection/","page":"Shadow intersections","title":"Shadow intersections","text":"After moving around the ways, we now evaluate the effect of the shadows of the buildings, trees... on the ways in the network. The main function intended for use here is MinistryOfCoolWalks.add_shadow_intervals!. To check for possible errors we provide MinistryOfCoolWalks.check_shadow_angle_integrity","category":"page"},{"location":"ShadowIntersection/#API","page":"Shadow intersections","title":"API","text":"","category":"section"},{"location":"ShadowIntersection/","page":"Shadow intersections","title":"Shadow intersections","text":"Pages = [\"ShadowIntersection.md\"]","category":"page"},{"location":"ShadowIntersection/","page":"Shadow intersections","title":"Shadow intersections","text":"Modules = [MinistryOfCoolWalks]\nPages = [\"ShadowIntersection.jl\"]","category":"page"},{"location":"ShadowIntersection/#MinistryOfCoolWalks.add_shadow_intervals!-Tuple{Any, Any}","page":"Shadow intersections","title":"MinistryOfCoolWalks.add_shadow_intervals!","text":"add_shadow_intervals!(g, shadows; clear_old_shadows=false)\n\nadds the intersection of the polygons in the :geometry column of the in dataframe shadows  and the geometry in the edgeprop :sg_street_geometry of graph g to g.\n\nThis operation can be repeated on the same graph with various shadows.\n\nIf clear_old_shadows is true, all possible, preexisting effects of previous executions of this function are reset. This way, a once loaded graph can be reused for multiple experiments.\n\nAfter this operation, all non-helper edges will have the additional property of :sg_shadow_length. This value is zero, if there is no shadow cast on the edge. If there is a shadow cast on the edge, the edge will have an additional property, :sg_shadow_geometry, representing the geometry of the street in the shadow.\n\n\n\n\n\n","category":"method"},{"location":"ShadowIntersection/#MinistryOfCoolWalks.all_less_than-Tuple{Any, Any}","page":"Shadow intersections","title":"MinistryOfCoolWalks.all_less_than","text":"all_less_than(angles, max_angle)\n\nchecks if all values in angles are less than max_angle.\n\n\n\n\n\n","category":"method"},{"location":"ShadowIntersection/#MinistryOfCoolWalks.angles_in-Tuple{Any}","page":"Shadow intersections","title":"MinistryOfCoolWalks.angles_in","text":"angles_in(line)\nangles_in(::MultiLineStringTrait, lines)\nangles_in(::LineStringTrait, line)\n\ncalculates all angles between segments in line. Result in radians.\n\n\n\n\n\n","category":"method"},{"location":"ShadowIntersection/#MinistryOfCoolWalks.check_shadow_angle_integrity-Tuple{Any, Any}","page":"Shadow intersections","title":"MinistryOfCoolWalks.check_shadow_angle_integrity","text":"check_shadow_angle_integrity(g, max_angle)\n\nchecks, if all angles in shadows (:sg_shadow_geometry) in g are less than max_angle (in radians). If not, prints a warning. Used to test if the shadow joining works as intended.\n\n\n\n\n\n","category":"method"},{"location":"ShadowIntersection/#MinistryOfCoolWalks.combine_along_tree-NTuple{4, Any}","page":"Shadow intersections","title":"MinistryOfCoolWalks.combine_along_tree","text":"combine_along_tree(tree, start_node, lines, min_dist)\n\nrecursively combines the lines at leafs in tree with the nodes one order up,  starting (as in, the recursion starts here. This node gets combined last) at the root start_node. The min_dist is needed to figure out how the lines should be combined. (This dependency could maybe be removed...)\n\n\n\n\n\n","category":"method"},{"location":"ShadowIntersection/#MinistryOfCoolWalks.combine_lines-Tuple{Any, Any, Any}","page":"Shadow intersections","title":"MinistryOfCoolWalks.combine_lines","text":"combine_lines(a, b, min_dist)\n\ncombines two lines a and b at the ends where they are closer than min_dist apart. This assumes, that a and b are (much) longer than min_dist. If not, weird edge cases may arrise.\n\nIf a ⊂ b, returns b, if b ⊂ a returns a. Otherwise, returns all nodes of a, concatenated with all nodes of b, which are further away from a than min_dist. If a and b form a circle, special care is taken to not mess up the order.\n\n\n\n\n\n","category":"method"},{"location":"ShadowIntersection/#MinistryOfCoolWalks.join_shadow_without_union!-Tuple{Any, ArchGDAL.IGeometry{ArchGDAL.wkbLineString}}","page":"Shadow intersections","title":"MinistryOfCoolWalks.join_shadow_without_union!","text":"join_shadow_without_union!(full_shadow, new_shadow::ArchGDAL.IGeometry{ArchGDAL.wkbLineString})\njoin_shadow_without_union!(full_shadow, new_shadow::ArchGDAL.IGeometry{ArchGDAL.wkbMultiLineString})\n\nadds new_shadow to full_shadow, skipping empty linestrings.\n\n\n\n\n\n","category":"method"},{"location":"ShadowIntersection/#MinistryOfCoolWalks.rebuild_lines-Tuple{ArchGDAL.IGeometry{ArchGDAL.wkbMultiLineString}, Any}","page":"Shadow intersections","title":"MinistryOfCoolWalks.rebuild_lines","text":"rebuild_lines(lines::ArchGDAL.IGeometry{ArchGDAL.wkbMultiLineString}, min_dist)::EdgeGeomType\nrebuild_lines(lines, min_dist)::EdgeGeomType\n\ncalculates the union of lines in a (multi) linestring, merging lines which are closer than min_dist to one another.\n\nWe calculate the adjacency matrix of all lines, build a network with edges where the distance between edges < min_dist, calculate a dfs tree for each connected component and recursively combine the linestrings at the leafs with the linestrings one level up.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MinistryOfCoolWalks","category":"page"},{"location":"#MinistryOfCoolWalks","page":"Home","title":"MinistryOfCoolWalks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MinistryOfCoolWalks.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MinistryOfCoolWalks]\nPages = [\"MinistryOfCoolWalks.jl\"]","category":"page"},{"location":"CenterlineCorrection/#Centerline-Correction","page":"Centerline correction","title":"Centerline Correction","text":"","category":"section"},{"location":"CenterlineCorrection/#Introduction","page":"Centerline correction","title":"Introduction","text":"","category":"section"},{"location":"CenterlineCorrection/","page":"Centerline correction","title":"Centerline correction","text":"When loading shadow graph from OSM data, the street geometry represents, by convention, the center of the streets, which usually is not the place where we see pedestrians walking. To get a more accurate picture of how much shadow there is on the sidewalks, we need to offset the ways to where pedestrians would usually walk. This procedure, including estimating the width of the street is handled here.","category":"page"},{"location":"CenterlineCorrection/#Default-values","page":"Centerline correction","title":"Default values","text":"","category":"section"},{"location":"CenterlineCorrection/","page":"Centerline correction","title":"Centerline correction","text":"As the datamodel of OSM allows for a certain variability in completeness of the mapped tags on each street, we need to assume some sensible default values for the width of streets, as well as for the types of highways which denote the centerline of streets vs pedestrian spaces. We have:","category":"page"},{"location":"CenterlineCorrection/","page":"Centerline correction","title":"Centerline correction","text":"MinistryOfCoolWalks.DEFAULT_LANES_ONEWAY\nMinistryOfCoolWalks.HIGHWAYS_OFFSET\nMinistryOfCoolWalks.HIGHWAYS_NOT_OFFSET","category":"page"},{"location":"CenterlineCorrection/","page":"Centerline correction","title":"Centerline correction","text":"If you encounter highways in your dataset which are not present, or would like to change the values given, you can update/add/... them as you need.","category":"page"},{"location":"CenterlineCorrection/#API","page":"Centerline correction","title":"API","text":"","category":"section"},{"location":"CenterlineCorrection/","page":"Centerline correction","title":"Centerline correction","text":"Pages = [\"CenterlineCorrection.md\"]","category":"page"},{"location":"CenterlineCorrection/","page":"Centerline correction","title":"Centerline correction","text":"Modules = [MinistryOfCoolWalks]\nPages = [\"CenterlineCorrection.jl\"]","category":"page"},{"location":"CenterlineCorrection/#MinistryOfCoolWalks.DEFAULT_LANES_ONEWAY","page":"Centerline correction","title":"MinistryOfCoolWalks.DEFAULT_LANES_ONEWAY","text":"DEFAULT_LANES_ONEWAY\n\ndefault number of lanes in one direction of the street, by highway type. Used as a fallback when there is no data available in the tags.\n\n\n\n\n\n","category":"constant"},{"location":"CenterlineCorrection/#MinistryOfCoolWalks.HIGHWAYS_NOT_OFFSET","page":"Centerline correction","title":"MinistryOfCoolWalks.HIGHWAYS_NOT_OFFSET","text":"HIGHWAYS_NOT_OFFSET\n\nlist of highways, which should not be offset, usually because they can allready considered the center of a bikepath/sidewalk/footpath...\n\n\n\n\n\n","category":"constant"},{"location":"CenterlineCorrection/#MinistryOfCoolWalks.HIGHWAYS_OFFSET","page":"Centerline correction","title":"MinistryOfCoolWalks.HIGHWAYS_OFFSET","text":"HIGHWAYS_OFFSET\n\nlist of highways, which should be offset to the edge of the street.\n\n\n\n\n\n","category":"constant"},{"location":"CenterlineCorrection/#MinistryOfCoolWalks.check_building_intersection-Tuple{Any, Any}","page":"Centerline correction","title":"MinistryOfCoolWalks.check_building_intersection","text":"check_building_intersection(building_tree, offset_linestring)\n\nchecks if the linestring offset_linestring interescts with any of the buildings saved in the building_tree, which is assumend to be an RTree of the same structure as generated by build_rtree. Returns the offending geometry, or an empty list, if there are no intersections.\n\n\n\n\n\n","category":"method"},{"location":"CenterlineCorrection/#MinistryOfCoolWalks.correct_centerlines!","page":"Centerline correction","title":"MinistryOfCoolWalks.correct_centerlines!","text":"correct_centerlines!(g, buildings, assumed_lane_width=3.5, scale_factor=1.0)\n\noffsets the centerlines of streets (edges in g) stored in the edge prop :eg_geometry_base, to the estimated edge of the street and stores the result in :sg_street_geometry.\n\nRepeated application of this function deletes all edgeprops added after loading the graph, or the last application of correct_centerline, apart from [:sg_osm_id, :sg_tags, :sg_street_geometry, :sg_geometry_base, :sg_street_length, :sg_parsing_direction, :sg_helper].\n\nThe information available in the edgeprops :sg_tags and :sg_parsing_direction is used to estimate the width of the street.  If it is not possible to find the offset using these props, the assumed_lane_width is used in conjunction with the gloabal dicts DEFAULT_LANES_ONEWAY, HIGHWAYS_OFFSET and HIGHWAYS_NOT_OFFSET, to figure out how far the edge should be offset. This guess is then multiplied by the scale_factor, to get the final distance by wich we then offset the line.\n\nIf the highway is in HIGHWAYS_NOT_OFFSET, it is not going to be moved, no matter the contents of its tags. For the full reasoning and implementations see the source of guess_offset_distance.\n\nWe check if the offset line does intersect more buildings than the original line, to make sure that the assumend foot/bike path does lead through a building. If there have new intersections arrisen, we retry the offsetting with 0.9, 0.8, 0.7... times the guessed offset, while checking and, if true breaking, whether the additional intersections vanish.\n\nWe also update the locations of the helper nodes, to reflect the offset lines, as well as the \":sgstreetlength\" prop, to reflect the possible change in length.\n\n\n\n\n\n","category":"function"},{"location":"CenterlineCorrection/#MinistryOfCoolWalks.guess_offset_distance","page":"Centerline correction","title":"MinistryOfCoolWalks.guess_offset_distance","text":"guess_offset_distance(g, edge::Edge, assumed_lane_width=3.5)\n\nestimates the the distance an edge of graph g has to be offset. Uses the props of the edge, the assumed_lane_width, used as a fallback in case the information can not be found solely in the props, as well as the global constants of DEFAULT_LANES_ONEWAY, HIGHWAYS_OFFSET and HIGHWAYS_NOT_OFFSET. This function calls:\n\nguess_offset_distance(edge_tags, parsing_direction, assumed_lane_width=3.5)\n\nestimates the distance the edge with the tags edge_tags, which has been parse in the direction of parsing_direction. (That is, if we had to go forwards or backwards through the OSM way in order to generate the edgeometry for this linestring. This is nessecary, due to the existence of the reverseway tags and possible asymetries, where streets have more lanes in one direction, than in the other.)\n\n\n\n\n\n","category":"function"},{"location":"CenterlineCorrection/#MinistryOfCoolWalks.node_directions-Tuple{Any, Any}","page":"Centerline correction","title":"MinistryOfCoolWalks.node_directions","text":"node_directions(x, y)\n\ncalculates the (scaled) direction in which the nodes given by 'x' and 'y' coordinates need to be offset, such that the connections between the nodes remain parallel to the original connections. Returns array of 2d vectors.\n\n\n\n\n\n","category":"method"},{"location":"CenterlineCorrection/#MinistryOfCoolWalks.offset_line-Tuple{Any, Any}","page":"Centerline correction","title":"MinistryOfCoolWalks.offset_line","text":"offset_line(line, distance)\n\ncreates new ArchGDAL linestring where all segments are offset parallel to the original segment of line, with a distance of distance. Looking down the line (from the first segment to the second...), a positive distance moves the line to the right, a negative distance to the left. The line is expected to be in a projected coordinate system, which is going to be applied to the new, offset line as well. If, continious offsetting the length of a line segment where to reach a length of 0, the two adjacent points are automatically merged and offsetting is continued using the new configuration. Does account for self intersections created by the the endpoints crossing a line segment. In this case, only the closed part of the curve will be preserved.\n\n\n\n\n\n","category":"method"}]
}
